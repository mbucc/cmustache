<!DOCTYPE html>

<html>
<head>
  <title>cmustache.c</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>cmustache.c</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;sys/errno.h&gt;</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ctype.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;err.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;limits.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;stddef.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;sysexits.h&gt;</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "js0n.h"</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "j0g.h"</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "htmlescape.h"</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "vec.h"</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "cmustache.h"</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BUFSZ_DELTA	10240</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DOT			'.'</span>


		<span class="hljs-comment">/*
		 * Add -DDEUG to CFLAGS in Makefile to turn on debug output.
		 */</span>
<span class="hljs-preprocessor">#ifdef DEBUG</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEBUG_PRINT 1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEBUG_PRINT 0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> debug_printf(fmt, ...) \</span>
        <span class="hljs-keyword">do</span> { <span class="hljs-keyword">if</span> (DEBUG_PRINT) <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"%s:%d:%s(): "</span> fmt, __FILE__, \
                                __LINE__, __func__, __VA_ARGS__); } <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The js0n library scans the json string
and records the (offset, length) pair for each key and each value
found in the json string.</p>
<p>This routine calculates the size of the array (*iszp) required
for the given a json string
and allocates a storage array of unsigned shorts (**indexp).</p>
<p>If the memory allocation fails, it returns ENOMEM.</p>
<p>If the required length overflows an unsigned int, 
it returns EX_TOO_MANY_KEYVAL_PAIRS.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
size_index(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *json, size_t jsonlen, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> **indexp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *iszp)
{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>	*p;
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;
	size_t		n = <span class="hljs-number">0</span>;

		<span class="hljs-comment">/*
		 * (one key + one value) x (one offset + one length) = 4
		 */</span>

	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> entries_per_comma = <span class="hljs-number">4</span>;

		<span class="hljs-comment">/*
		 * We need at least one extra slot (js0n zero-terminates
		 * the array) plus four for the last key/value pair.
		 * Add some more for safety ...
		 */</span>

	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> extra = <span class="hljs-number">21</span>;

		<span class="hljs-comment">/*
		 * The number of commas in JSON is an upper limit
		 * on the number of key/value pairs - 1.
		 * 
		 * Note: On my macbook pro, it takes 8.62 seconds to count
		 * to UINT_MAX by one's.  Probably could use a lower limit.
		 */</span>

	<span class="hljs-keyword">for</span> (p = json; !rval &amp;&amp; p - json &lt; jsonlen; p++) {
		n += (*p == <span class="hljs-string">','</span>);
		<span class="hljs-keyword">if</span> (n &gt;= UINT_MAX)
			rval = EX_TOO_MANY_KEYVAL_PAIRS;
	}
		<span class="hljs-comment">/*
		 * The array holds short ints, but the array index
		 * is an unsigned int, so we check against UINT_MAX.
		 */</span>

	<span class="hljs-keyword">if</span> (!rval &amp;&amp; n &gt; UINT_MAX / entries_per_comma - extra)
		rval = EX_TOO_MANY_KEYVAL_PAIRS;

	<span class="hljs-keyword">if</span> (!rval) {
		*iszp = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) n;
		*iszp *= entries_per_comma;
		*iszp += extra;
		<span class="hljs-keyword">if</span> ((*indexp = <span class="hljs-built_in">calloc</span>(*iszp, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>))) == NULL)
			rval = ENOMEM;
	}

	<span class="hljs-keyword">return</span> rval;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Allocate and load the set of offset and length pairs
for the key/values in the given JSON.  Zero-terminate
the array.</p>
<p>Returns 0 on success, 
EX_JSON_PARSE_ERROR if there was an error parsing JSON.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
index_json(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *json, size_t jsonlen, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> **indexp)
{
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>	isz;

	<span class="hljs-keyword">if</span> (!json || !<span class="hljs-built_in">strlen</span>(json) || !indexp)
		<span class="hljs-keyword">return</span> rval;

	rval = size_index(json, jsonlen, indexp, &amp;isz);

	<span class="hljs-keyword">if</span> (!rval) {

		rval = js0n((<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) json, jsonlen, *indexp, isz);

		<span class="hljs-keyword">if</span> (rval)

			rval = EX_JSON_PARSE_ERROR;
	}

	<span class="hljs-keyword">return</span> rval;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Return 1 if the first non-whitespace character in json is a ‘{‘, 0 otherwise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
is_obj(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *json, size_t jsonlen) 
{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>	*p;
	<span class="hljs-keyword">for</span> (p = json; <span class="hljs-built_in">isspace</span>(*p) &amp;&amp; p - json &lt; jsonlen; p++);
	<span class="hljs-keyword">return</span> *p == <span class="hljs-string">'{'</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Move the offset and length so
the character sequence they define
does not start or end with whitespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">void</span>
trim(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *json, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *offset, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *length)
{
	<span class="hljs-keyword">if</span> (!offset || !length || !json)
		<span class="hljs-keyword">return</span>;

	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">isspace</span>(*(json + *offset)) &amp;&amp; *length &gt; <span class="hljs-number">0</span>) {
		(*offset)++;
		(*length)--;
	}

	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">isspace</span>(*(json + *offset + *length - <span class="hljs-number">1</span>)) &amp;&amp; *length &gt; <span class="hljs-number">0</span>) {
		(*length)--;
	}

}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Given a json string and a key, 
return the offset and length
of the key’s value.</p>
<p>If key is not found, offset is set to 0.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
jsonpath(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *json, size_t jsonlen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, 
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *offset, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> *length)
{
	<span class="hljs-keyword">char</span>		*keybuf = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span>		*p = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	*index = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	suboffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	sublength = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		idx = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (!offset || !length)
		<span class="hljs-keyword">return</span> EX_LOGIC_ERROR;

	*offset = <span class="hljs-number">0</span>;
	*length = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>An empty key never has a value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!key || !<span class="hljs-built_in">strlen</span>(key))
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	debug_printf(<span class="hljs-string">"jsonpath('%s', %lu, '%s')\n"</span>, json, jsonlen, key);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Nor does a key in empty json.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!json || !<span class="hljs-built_in">strlen</span>(json))
		<span class="hljs-keyword">return</span> rval;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Only json objects have keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( ! is_obj(json, jsonlen) )
		<span class="hljs-keyword">return</span> rval;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Look for key in current JSON object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	rval = index_json(json, jsonlen, &amp;index);
	<span class="hljs-keyword">if</span> (!rval) {
		idx = j0g_val(key, (<span class="hljs-keyword">char</span> *) json, index);

		<span class="hljs-keyword">if</span> (idx != <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>We found the key.<br>Set offset, length, and trim off whitespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			*offset = index[idx];
			*length = index[idx + <span class="hljs-number">1</span>];
			trim(json, offset, length);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>We didn’t find the key so try to recurse down through json.</p>
<p>For example,
if the key = “a.b”
and we didn’t find “a.b” as an attribute of  the top-level json object,
then …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">if</span> (!rval &amp;&amp; *offset == <span class="hljs-number">0</span>) {
		keybuf = <span class="hljs-built_in">calloc</span>(<span class="hljs-built_in">strlen</span>(key), <span class="hljs-number">1</span>);
		<span class="hljs-keyword">if</span> (!keybuf)
			rval = ENOMEM;
	}

	<span class="hljs-keyword">if</span> (!rval &amp;&amp; *offset == <span class="hljs-number">0</span>) {
		<span class="hljs-built_in">strcpy</span>(keybuf, key);
		p = <span class="hljs-built_in">strchr</span>(keybuf, DOT);
		<span class="hljs-keyword">if</span> (p) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>… we look for a top-level attribute named “a” …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			*p++ = <span class="hljs-string">'\0'</span>;
			idx = j0g_val(keybuf, (<span class="hljs-keyword">char</span> *) json, index);
			<span class="hljs-keyword">if</span> (idx != <span class="hljs-number">0</span>) {
				suboffset = index[idx];
				sublength = index[idx + <span class="hljs-number">1</span>];
				json += suboffset;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>… and look for the key “b” in that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				rval =  jsonpath(json, sublength, p, offset, length);

				<span class="hljs-keyword">if</span> (!rval &amp;&amp; *offset != <span class="hljs-number">0</span>) {
					trim(json, offset, length);
					*offset += suboffset;
				}
				<span class="hljs-keyword">else</span>
					<span class="hljs-comment">/* EMTPY -- if offset is zero, then key is not found. */</span>
					;
			}
			<span class="hljs-keyword">else</span>
				<span class="hljs-comment">/* EMPTY -- if an part of key is not found, then the full key is not found. */</span>
				;
		}
		<span class="hljs-keyword">else</span>
			<span class="hljs-comment">/* EMPTY -- no dots in key, so no subsection to look in ... the key's not found. */</span>
			;
	}


	<span class="hljs-built_in">free</span>(index);
	<span class="hljs-built_in">free</span>(keybuf);

	debug_printf(<span class="hljs-string">"		--&gt; jsonpath returns offset, length = %u, %u\n"</span>, *offset, *length);
		
	<span class="hljs-keyword">return</span> rval;

}

<span class="hljs-keyword">void</span>
sectiontocontext(<span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> fromidx, <span class="hljs-keyword">int</span> sections_n, <span class="hljs-keyword">char</span> *dst)
{
	*dst = <span class="hljs-string">'\0'</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = fromidx; i &lt; sections_n; i++) {
		<span class="hljs-keyword">if</span> (i &gt; fromidx)
			<span class="hljs-built_in">strcat</span>(dst, DOT);
		<span class="hljs-built_in">strcat</span>(dst, section[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sectiontocontext(...,%d, %d) --&gt; '%s'\n"</span>, fromidx, sections_n, dst);
}

<span class="hljs-keyword">int</span>
peeloff_sections_from_top(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  * <span class="hljs-keyword">const</span> json, size_t jsonlen, 
		<span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> sections_n, 
		<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">char</span> **val)
{
	<span class="hljs-keyword">char</span>		context[(MAX_KEYSZ + <span class="hljs-number">1</span>) * MAX_SECTION_DEPTH + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>		*p;
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		loop_limit = <span class="hljs-number">1000</span>;
	<span class="hljs-keyword">int</span>		loop_i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		fromidx = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	offset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	length = <span class="hljs-number">0</span>;

	sectiontocontext(section, fromidx, sections_n, context);

	p = json;

	<span class="hljs-keyword">while</span> ( !rval &amp;&amp; !*val &amp;&amp; <span class="hljs-built_in">strlen</span>(context) ) {
	
		<span class="hljs-keyword">if</span> (loop_i++ &gt;= loop_limit)
			rval = EX_LOGIC_ERROR;

		<span class="hljs-keyword">if</span> (!rval)
			rval = jsonpath(p, jsonlen, context, &amp;offset, &amp;length);

		<span class="hljs-keyword">if</span> (!rval &amp;&amp; offset) {

		<span class="hljs-comment">/*
		 * The JSON has this section, see if the section has the key.
		 */</span>

			p += offset;
			rval = jsonpath(p, length, key, &amp;offset, &amp;length);
		}

		<span class="hljs-keyword">if</span> (!rval &amp;&amp; offset) {

		<span class="hljs-comment">/*
		 * We found the key in the current section.
		 */</span>

			*val = <span class="hljs-built_in">calloc</span>(length + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
			<span class="hljs-keyword">if</span> (*val)
				<span class="hljs-built_in">strncat</span>(*val, p + offset, length);
			<span class="hljs-keyword">else</span>
				rval = ENOMEM;
		}
		
		<span class="hljs-keyword">if</span> (!rval &amp;&amp; !*val) {
			fromidx++;
			sectiontocontext(section, fromidx, sections_n, context);
		}

	}

	<span class="hljs-keyword">return</span> rval;

}

<span class="hljs-keyword">int</span>
peeloff_sections_from_bottom(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  * <span class="hljs-keyword">const</span> json, size_t jsonlen,
		<span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> sections_n, 
		<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">char</span> **val)
{
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	offset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	length = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> depth = sections_n; !rval &amp;&amp; !*val &amp;&amp; depth &gt; <span class="hljs-number">0</span>; depth--) {
	
		<span class="hljs-keyword">if</span> (loop_i++ &gt;= loop_limit)
			rval = EX_LOGIC_ERROR;

		<span class="hljs-keyword">if</span> (!rval)
			rval = jsonpath(p, jsonlen, context, &amp;offset, &amp;length);

		<span class="hljs-keyword">if</span> (!rval &amp;&amp; offset) {
			p += offset;
			rval = jsonpath(p, length, key, &amp;offset, &amp;length);
		}

		<span class="hljs-keyword">if</span> (!rval &amp;&amp; offset) {
			*val = <span class="hljs-built_in">calloc</span>(length + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
			<span class="hljs-keyword">if</span> (*val)
				<span class="hljs-built_in">strncat</span>(*val, p + offset, length);
			<span class="hljs-keyword">else</span>
				rval = ENOMEM;
		}
		
		<span class="hljs-keyword">if</span> (!rval &amp;&amp; !*val)
			sectiontocontext(section, <span class="hljs-number">0</span>, sections_n--, context);

	}

	<span class="hljs-keyword">return</span> rval;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Lookup a key’s value and copy it to *val.
If the key is not found, *val is set to NULL.</p>
<p>If sections_n &gt; 0, the key is looked up in the context of the given section.
See the file specs/resolution.json for details on how that works.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
get(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>  * <span class="hljs-keyword">const</span> json, size_t jsonlen, 
		<span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> sections_n, 
		<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">char</span> **val)
{
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	offset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>	length = <span class="hljs-number">0</span>;

	debug_printf(<span class="hljs-string">"get('%s', %lu, '%s', '%s')\n"</span>, json, jsonlen, section[sections_n], key);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The val pointer must be allocated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!val)
		<span class="hljs-keyword">return</span> EX_LOGIC_ERROR;

	*val = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>An empty json string is not an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!json || !<span class="hljs-built_in">strlen</span>(json))
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

<span class="hljs-comment">/*

	if (!rval)
		rval = peeloff_sections_from_top(json, jsonlen, section, sections_n, key, val);
*/</span>


	<span class="hljs-keyword">if</span> (!rval &amp;&amp; !*val)
		rval = peeloff_sections_from_bottom(json, jsonlen, section, sections_n, key, val);

		<span class="hljs-comment">/*
		 * If not found in section, try global context.
		 */</span>

	<span class="hljs-keyword">if</span> (!rval &amp;&amp; !*val) {

		rval = jsonpath(json, jsonlen, key, &amp;offset, &amp;length);

		<span class="hljs-keyword">if</span> (!rval) {
			<span class="hljs-keyword">if</span>  (offset) {
				*val = <span class="hljs-built_in">calloc</span>(length + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span> (*val)
					<span class="hljs-built_in">strncat</span>(*val, json + offset, length);
				<span class="hljs-keyword">else</span>
					rval = ENOMEM;
			}
		}
				
	}

	debug_printf(<span class="hljs-string">"\"%s\" returns \"%s\" (rval = %d)\n"</span>, key, *val, rval);

	<span class="hljs-keyword">return</span> rval;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Look up value in JSON for the given key, and insert it into the result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
insert_value(<span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> sections_n, <span class="hljs-keyword">char</span> *tag, <span class="hljs-keyword">char</span> **qhtml, <span class="hljs-keyword">char</span> *json, <span class="hljs-keyword">int</span> raw)
{
	<span class="hljs-keyword">int</span> 		rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span>		*val = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span>		*escaped = <span class="hljs-number">0</span>;

	debug_printf(<span class="hljs-string">"insert_value('%s', '%s', '%s', '%s', %d)\n"</span>, section[sections_n], tag, *qhtml, json, raw);

	<span class="hljs-keyword">if</span> (!rval) {
		<span class="hljs-comment">/*
		 * A tag that starts with an ampersand
		 * is the same as a triple brace.
		 */</span>
	
		<span class="hljs-keyword">if</span> (tag[<span class="hljs-number">0</span>] == <span class="hljs-string">'&amp;'</span>) {
			raw = <span class="hljs-number">1</span>;
			tag = tag + <span class="hljs-number">1</span>;
		}
	}

	<span class="hljs-keyword">if</span> (!rval)
		rval = get(json, <span class="hljs-built_in">strlen</span>(json), section, sections_n, tag, &amp;val);


	<span class="hljs-keyword">if</span> (!rval) {
		<span class="hljs-keyword">if</span> (raw)
			escaped = val;
		<span class="hljs-keyword">else</span>
			rval = htmlescape(val, &amp;escaped);
	}

	<span class="hljs-keyword">if</span> (!rval &amp;&amp; escaped) {
		<span class="hljs-built_in">strcpy</span>(*qhtml, escaped);
		*qhtml += <span class="hljs-built_in">strlen</span>(*qhtml);
	}

	<span class="hljs-keyword">if</span> (!raw)
		<span class="hljs-built_in">free</span>(escaped);

	<span class="hljs-keyword">return</span> rval;
}

		<span class="hljs-comment">/*
		 * Return true if the character is in the given, inclusive, range.
		 */</span>
<span class="hljs-keyword">int</span> 
in(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">char</span> lo, <span class="hljs-keyword">char</span> hi)
{
	<span class="hljs-keyword">return</span> (c &gt;= lo) &amp;&amp; (c &lt;= hi);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><a href="http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters">http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
badchar(<span class="hljs-keyword">char</span> c)
{
	<span class="hljs-keyword">return</span>  in(c, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>)
		|| in(c, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>)
		|| in(c, <span class="hljs-number">14</span>, <span class="hljs-number">31</span>)
		|| in(c, <span class="hljs-number">127</span>, <span class="hljs-number">159</span>)
		;
}

<span class="hljs-keyword">int</span>
add_to_tag(<span class="hljs-keyword">char</span> **qtag, <span class="hljs-keyword">char</span> *tag, <span class="hljs-keyword">char</span> c)
{
	debug_printf(<span class="hljs-string">"add_to_tag('%s', '%s', %c)\n"</span>, *qtag, tag, c);
	<span class="hljs-keyword">if</span> (*qtag - tag &gt;= MAX_KEYSZ - <span class="hljs-number">1</span>)
		<span class="hljs-keyword">return</span> EX_TAG_TOO_LONG;
	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isspace</span>(c))
		*(*qtag)++ = c;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

		<span class="hljs-comment">/*
		 * As we drill deeper into sub and subsections,
		 * just mash them together with a period delimiter.
		 *
		 * Dotted names are section short-hand in the spec,
		 * so this should work.
		 *
		 * While not specified in the interpolation spec,
		 * we do prohibit periods in the section names.
		 */</span>

<span class="hljs-keyword">int</span>
push_section(<span class="hljs-keyword">char</span> *tag,  <span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> *sections_n)
{
	<span class="hljs-keyword">int</span> rval = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span> (!tag || !<span class="hljs-built_in">strlen</span>(tag))
		<span class="hljs-keyword">return</span> rval;

	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(tag) + <span class="hljs-number">1</span> &gt;= MAX_KEYSZ)
		rval = EX_TAG_TOO_LONG;

	<span class="hljs-keyword">if</span> (*sections_n &gt;= MAX_SECTION_DEPTH - <span class="hljs-number">1</span>)
		rval = EX_TOO_MANY_SECTIONS;

	<span class="hljs-keyword">if</span> (!rval)
		<span class="hljs-built_in">strcpy</span>(section[(*sections_n)++], tag);
	
	<span class="hljs-keyword">if</span> (!rval)
		debug_printf(<span class="hljs-string">"		push_section('%s') --&gt; 'sections_n = %d'\n"</span>, tag, *sections_n);
	<span class="hljs-keyword">else</span>
		debug_printf(<span class="hljs-string">"		push_section('%s') --&gt; 'rval = %d'\n"</span>, tag, rval);

	<span class="hljs-keyword">return</span> rval;
}


<span class="hljs-keyword">int</span>
pop_section(<span class="hljs-keyword">char</span> *tag, <span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> *sections_n)
{
	<span class="hljs-keyword">int</span> rval = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (!tag || !<span class="hljs-built_in">strlen</span>(tag))

		<span class="hljs-comment">/*
		 * Ignore empty tags.
		 */</span>

		<span class="hljs-keyword">return</span> rval;

	<span class="hljs-keyword">if</span> (sections_n == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(tag, section[*sections_n - <span class="hljs-number">1</span>]) )
			rval = EX_POP_DOES_NOT_MATCH;

	<span class="hljs-keyword">if</span> (!rval)
		section[(*sections_n)--][<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;

	<span class="hljs-keyword">if</span> (!rval)
		debug_printf(<span class="hljs-string">"		pop_section('%s') --&gt; sections_n = %d\n"</span>, tag, *sections_n);
	<span class="hljs-keyword">else</span>
		debug_printf(<span class="hljs-string">"		pop_section('%s') --&gt; rval = %d\n"</span>, tag, rval);

	<span class="hljs-keyword">return</span> rval;
}

<span class="hljs-keyword">int</span>
is_section_falsey(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *json, <span class="hljs-keyword">char</span> section[][MAX_KEYSZ], <span class="hljs-keyword">int</span> sections_n, <span class="hljs-keyword">int</span> *drop)
{
	<span class="hljs-keyword">char</span> *val = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span>	tag[(MAX_KEYSZ + <span class="hljs-number">1</span>) * MAX_SECTION_DEPTH] = {<span class="hljs-number">0</span>};
	<span class="hljs-keyword">int</span> rval = <span class="hljs-number">0</span>;

	*drop = <span class="hljs-number">0</span>;
	sectiontocontext(section, <span class="hljs-number">0</span>, sections_n, tag);
	<span class="hljs-keyword">if</span> (tag &amp;&amp; <span class="hljs-built_in">strlen</span>(tag))
		rval = get(json, <span class="hljs-built_in">strlen</span>(json), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, tag, &amp;val);

		<span class="hljs-comment">/*
		 * Only drop section if it is explicitly
		 * set to falsey in JSON.
		 */</span>

	<span class="hljs-keyword">if</span> (!rval &amp;&amp; val &amp;&amp; *val)
		*drop = !<span class="hljs-built_in">strcmp</span>(val, <span class="hljs-string">"false"</span>);

	debug_printf(<span class="hljs-string">"is_section_falsey('%s', '%s') --&gt; %d (rval = %d)\n"</span>, json, tag, *drop, rval);

	<span class="hljs-keyword">return</span> rval;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Given a mustache template and some JSON, render the HTML.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">int</span>
render(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">template</span>, <span class="hljs-keyword">char</span> *json, <span class="hljs-keyword">char</span> **html)
{
	<span class="hljs-keyword">char</span>		section[MAX_SECTION_DEPTH][MAX_KEYSZ] = {{<span class="hljs-number">0</span>}};
	<span class="hljs-keyword">char</span>		tag[MAX_KEYSZ] = {<span class="hljs-number">0</span>};
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>	*cur= <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span>		prev;
	<span class="hljs-keyword">char</span>		prevprev;
	<span class="hljs-keyword">char</span>		*qhtml = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span>		*qtag = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		sections_n = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		drop = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span>		rval = <span class="hljs-number">0</span>;

	debug_printf(<span class="hljs-string">"%s\n"</span>, <span class="hljs-string">"Starting to render"</span>);

		<span class="hljs-comment">/*
		 * The states and their transitions.
		 */</span>


	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gohtml[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">122</span>]	= &amp;&amp;l_html,
		[ <span class="hljs-string">'{'</span> ]		= &amp;&amp;l_tagp,
		[<span class="hljs-number">124</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_html
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gotagp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">122</span>]	= &amp;&amp;l_no_tag,
		[ <span class="hljs-string">'{'</span> ]		= &amp;&amp;l_rawtagp,
		[<span class="hljs-number">124</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_tag
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gorawtagp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">34</span>]	= &amp;&amp;l_no_rawtag,
		[ <span class="hljs-string">'#'</span> ]		= &amp;&amp;l_yes_push,	<span class="hljs-comment">// 35</span>
		[<span class="hljs-number">36</span> ... <span class="hljs-number">46</span>]	= &amp;&amp;l_no_rawtag,
		[ <span class="hljs-string">'/'</span> ]		= &amp;&amp;l_yes_pop,	<span class="hljs-comment">// 47</span>
		[<span class="hljs-number">48</span> ... <span class="hljs-number">122</span>]	= &amp;&amp;l_no_rawtag,
		[ <span class="hljs-string">'{'</span> ]		= &amp;&amp;l_yes_rawtag,	<span class="hljs-comment">// 123</span>
		[<span class="hljs-number">124</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_rawtag
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gopush[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">45</span> ]	= &amp;&amp;l_push,
		[ DOT ]		= &amp;&amp;l_bad_section,	<span class="hljs-comment">// 46</span>
		[<span class="hljs-number">47</span> ... <span class="hljs-number">124</span> ]	= &amp;&amp;l_push,
		[ <span class="hljs-string">'}'</span> ]		= &amp;&amp;l_xpushp,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_push
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *goxpushp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span> ]	= &amp;&amp;l_no_xpush,
		[ <span class="hljs-string">'}'</span> ]		= &amp;&amp;l_yes_xpush,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_xpush
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gopop[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">45</span> ]	= &amp;&amp;l_pop,
		[ DOT ]		= &amp;&amp;l_bad_section,	<span class="hljs-comment">// 46</span>
		[<span class="hljs-number">47</span> ... <span class="hljs-number">124</span> ]	= &amp;&amp;l_pop,
		[ <span class="hljs-string">'}'</span> ]		= &amp;&amp;l_xpopp,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_pop
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *goxpopp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span> ]	= &amp;&amp;l_no_xpop,
		[ <span class="hljs-string">'}'</span> ]			= &amp;&amp;l_yes_xpop,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_xpop
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gotag[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span> ]	= &amp;&amp;l_tag,
		[ <span class="hljs-string">'}'</span> ]			= &amp;&amp;l_xtagp,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_tag
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *goxtagp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span>]	= &amp;&amp;l_no_xtag,
		[ <span class="hljs-string">'}'</span> ]		= &amp;&amp;l_yes_xtag,
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_xtag
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *gorawtag[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span> ]	= &amp;&amp;l_rawtag,
		[ <span class="hljs-string">'}'</span> ]			= &amp;&amp;l_xrawpp,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_rawtag
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *goxrawpp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span>]	= &amp;&amp;l_no_xrawp,
		[ <span class="hljs-string">'}'</span> ]		= &amp;&amp;l_yes_xrawp,
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_xrawp
	};

	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *goxrawp[] =
	{
		[<span class="hljs-number">0</span> ... <span class="hljs-number">124</span>]	= &amp;&amp;l_no_xraw,
		[ <span class="hljs-string">'}'</span> ]		= &amp;&amp;l_yes_xraw,	<span class="hljs-comment">// 125</span>
		[<span class="hljs-number">126</span> ... <span class="hljs-number">255</span>]	= &amp;&amp;l_no_xraw
	};

		<span class="hljs-comment">/*
		 * Allocate memory to hold HTML.
		 */</span>

	<span class="hljs-keyword">if</span> (!rval) {

		*html = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">calloc</span>(BUFSZ_DELTA, <span class="hljs-number">1</span>);

		<span class="hljs-keyword">if</span>  ( *html == NULL)
			rval = ENOMEM;

		qhtml = *html;
	}

		<span class="hljs-comment">/*
		 * Start in the HTML state.
		 */</span>

	<span class="hljs-keyword">void</span> **go = gohtml;

		<span class="hljs-comment">/*
		 * Process template, one character at a time.
		 */</span>


	<span class="hljs-keyword">for</span>(cur = <span class="hljs-keyword">template</span>; *cur &amp;&amp; !rval; cur++)
	{
		debug_printf(<span class="hljs-string">"%c\n"</span>, *cur);
		<span class="hljs-keyword">if</span> (badchar(*cur))
			rval = EX_INVALID_CHAR;
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">goto</span> *go[(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) *cur];
		l_loop:
		prev = *cur;
		prevprev = prev;
	}

	<span class="hljs-keyword">return</span> rval;

		<span class="hljs-comment">/*
		 * The behavior on transition.
		 */</span>

	l_bad_section:
		rval = EX_INVALID_SECTION_NAME;
		<span class="hljs-keyword">goto</span> l_loop;

	l_html:
		<span class="hljs-keyword">if</span> (!drop)
			*qhtml++ = *cur;
		<span class="hljs-keyword">goto</span> l_loop;

	l_tagp:
		go = gotagp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gotagp"</span>, <span class="hljs-string">"l_tagp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_tag:
		*qhtml++ = prev;
		*qhtml++ = *cur;
		go = gohtml;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gohtml"</span>, <span class="hljs-string">"l_no_tag"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_rawtagp:
		go = gorawtagp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gorawtagp"</span>, <span class="hljs-string">"l_rawtagp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_rawtag:
		qtag = tag;
		rval = add_to_tag(&amp;qtag, tag, *cur);
		go = gotag;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gotag"</span>, <span class="hljs-string">"l_no_rawtag"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_push:
		qtag = tag;
		go = gopush;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gopush"</span>, <span class="hljs-string">"l_yes_push"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_pop:
		qtag = tag;
		go = gopop;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gopop"</span>, <span class="hljs-string">"l_yes_pop"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_rawtag:
		qtag = tag;
		go = gorawtag;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gorawtag"</span>, <span class="hljs-string">"l_yes_rawtag"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_push:
		<span class="hljs-comment">/* FALLTHROUGH */</span>

	l_pop:
		<span class="hljs-comment">/* FALLTHROUGH */</span>

	l_rawtag:
		<span class="hljs-comment">/* FALLTHROUGH */</span>

	l_tag:
		rval = add_to_tag(&amp;qtag, tag, *cur);
		<span class="hljs-keyword">goto</span> l_loop;

	l_xpushp:
		go = goxpushp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"goxpushp"</span>, <span class="hljs-string">"l_xpushp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_xpush:
		rval = add_to_tag(&amp;qtag, tag, prev);
		<span class="hljs-keyword">if</span> (!rval)
			rval = add_to_tag(&amp;qtag, tag, *cur);
		go = gopush;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gopush"</span>, <span class="hljs-string">"l_no_xpush"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_xpush:
		go = gohtml;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gohtml"</span>, <span class="hljs-string">"l_yes_xpush"</span>);
		rval = push_section(tag, section, &amp;sections_n);
		<span class="hljs-keyword">if</span> (!rval)
			rval = is_section_falsey(json, section, sections_n, &amp;drop);
		<span class="hljs-built_in">memset</span>(tag, <span class="hljs-number">0</span>, MAX_KEYSZ);
		<span class="hljs-keyword">goto</span> l_loop;

	l_xpopp:
		go = goxpopp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"goxpopp"</span>, <span class="hljs-string">"l_xpopp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_xpop:
		rval = add_to_tag(&amp;qtag, tag, prev);
		<span class="hljs-keyword">if</span> (!rval)
			rval = add_to_tag(&amp;qtag, tag, *cur);
		go = gopop;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gopop"</span>, <span class="hljs-string">"l_no_xpop"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_xpop:
		go = gohtml;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gohtml"</span>, <span class="hljs-string">"l_yes_xpop"</span>);
		rval = pop_section(tag, section, &amp;sections_n);
		<span class="hljs-keyword">if</span> (!rval)
			rval = is_section_falsey(json, section, sections_n, &amp;drop);
		<span class="hljs-built_in">memset</span>(tag, <span class="hljs-number">0</span>, MAX_KEYSZ);
		<span class="hljs-keyword">goto</span> l_loop;

	l_xtagp:
		go = goxtagp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"goxtagp"</span>, <span class="hljs-string">"l_xtagp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_xtag:
		rval = add_to_tag(&amp;qtag, tag, prev);
		<span class="hljs-keyword">if</span> (!rval)
			rval = add_to_tag(&amp;qtag, tag, *cur);
		go = gotag;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gotag"</span>, <span class="hljs-string">"l_no_xtag"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_xtag:
		go = gohtml;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gohtml"</span>, <span class="hljs-string">"l_yes_xtag"</span>);
		debug_printf(<span class="hljs-string">"before insert, html = \"%s\"\n"</span>, *html);
		<span class="hljs-keyword">if</span> (!drop)
			rval = insert_value(section, sections_n, tag, &amp;qhtml, json, <span class="hljs-number">0</span>);
		debug_printf(<span class="hljs-string">"after insert, html = \"%s\"\n"</span>, *html);
		<span class="hljs-built_in">memset</span>(tag, <span class="hljs-number">0</span>, MAX_KEYSZ);
		<span class="hljs-keyword">goto</span> l_loop;

	l_xrawpp:
		go = goxrawpp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"goxrawpp"</span>, <span class="hljs-string">"l_xrawpp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_xrawp:
		rval = add_to_tag(&amp;qtag, tag, prev);
		<span class="hljs-keyword">if</span> (!rval)
			rval = add_to_tag(&amp;qtag, tag, *cur);
		go = gorawtag;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gorawtag"</span>, <span class="hljs-string">"l_no_xrawp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_xrawp:
		go = goxrawp;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"goxrawp"</span>, <span class="hljs-string">"l_yes_xrawp"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_no_xraw:
		rval = add_to_tag(&amp;qtag, tag, prevprev);;
		<span class="hljs-keyword">if</span> (!rval)
			rval = add_to_tag(&amp;qtag, tag, prev);
		<span class="hljs-keyword">if</span> (!rval)
			rval = add_to_tag(&amp;qtag, tag, *cur);
		go = gorawtag;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gorawtag"</span>, <span class="hljs-string">"l_no_xraw"</span>);
		<span class="hljs-keyword">goto</span> l_loop;

	l_yes_xraw:
		go = gohtml;
		debug_printf(<span class="hljs-string">"\t\t--&gt; %s (%s)\n"</span>, <span class="hljs-string">"gohtml"</span>, <span class="hljs-string">"l_yes_xraw"</span>);
		debug_printf(<span class="hljs-string">"before insert raw, html = \"%s\"\n"</span>, *html);
		<span class="hljs-keyword">if</span> (!drop)
			rval = insert_value(section, sections_n, tag, &amp;qhtml, json, <span class="hljs-number">1</span>);
		debug_printf(<span class="hljs-string">"after insert raw, html = \"%s\"\n"</span>, *html);
		<span class="hljs-built_in">memset</span>(tag, <span class="hljs-number">0</span>, MAX_KEYSZ);
		<span class="hljs-keyword">goto</span> l_loop;

}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
